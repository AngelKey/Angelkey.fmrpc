// Generated by IcedCoffeeScript 108.0.11
(function() {
  var e, get_encode_lib, mp, mpmp, pp, set_opt, set_opts, _opts;

  try {
    mp = require('msgpack');
  } catch (_error) {
    e = _error;
  }

  try {
    pp = require('purepack');
  } catch (_error) {
    e = _error;
  }

  try {
    mpmp = require('@msgpack/msgpack');
  } catch (_error) {
    e = _error;
  }

  if ((mp == null) && (pp == null) && (mpmp == null)) {
    throw new Error("Need either msgpack, purepack, or @msgpack/msgpack to run");
  }

  _opts = {};

  exports.set_opt = set_opt = function(k, v) {
    return _opts[k] = v;
  };

  exports.set_opts = set_opts = function(o) {
    return _opts = o;
  };

  exports.get_encode_lib = get_encode_lib = function() {
    var encode_lib;
    encode_lib = _opts.encode_lib || "purepack";
    switch (encode_lib) {
      case "purepack":
      case "msgpack":
      case "@msgpack/msgpack":
        return encode_lib;
    }
    throw new Error("Unsupported encode library " + encode_lib);
  };

  exports.use_byte_arrays = function() {
    var encode_lib, err;
    if (pp == null) {
      try {
        encode_lib = get_encode_lib();
        switch (encode_lib) {
          case "purepack":
            return pp = require("purepack");
          case "msgpack":
            throw new Error("not supported");
            break;
          case "@msgpack/msgpack":
            return mpmp = require("@msgpack/msgpack");
        }
      } catch (_error) {
        err = _error;
        throw new Error("Cannot use_byte_arrays without 'purepack' or @msgpack/msgpack!");
      }
    }
  };

  exports.pack = function(b) {
    var encode_lib, encoded;
    encode_lib = get_encode_lib();
    switch (encode_lib) {
      case "purepack":
        return pp.pack(b);
      case "msgpack":
        return mp.pack(b);
      case "@msgpack/msgpack":
        encoded = mpmp.encode(b);
        return Buffer.from(encoded.buffer, encoded.byteOffset, encoded.byteLength);
    }
  };

  exports.unpack = function(b) {
    var dat, encode_lib, err;
    err = dat = null;
    encode_lib = get_encode_lib();
    switch (encode_lib) {
      case "purepack":
        try {
          dat = pp.unpack(b);
        } catch (_error) {
          err = _error;
        }
        break;
      case "msgpack":
        try {
          dat = mp.unpack(b);
        } catch (_error) {
          err = _error;
        }
        break;
      case "@msgpack/msgpack":
        try {
          dat = mpmp.decode(b);
        } catch (_error) {
          err = _error;
        }
    }
    return [err, dat];
  };

}).call(this);
